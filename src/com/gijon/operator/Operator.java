package com.gijon.operator;

import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;

import java.util.BitSet;

/**
 *  java 运算符
 */
public class Operator {

    public static void main(String[] args){
       /**
        * 1.算术运算符
        * 1-1:一元运算符： -   +   --   ++
        * 1-2:二元运算符： +   -   *  /  %
        */

        /**
         * 2.关系运算符: ==  !=  >  <  >=  <=
         */

        /**
         * 3.逻辑运算符: 逻辑与'&&'(短路)，逻辑或'||'（短路），逻辑非'!'，逻辑异或'^'（相同为false，相反为true），逻辑与'&'，逻辑或'|'
         */

        /**
         * 4.位运算符: 位与'&'，位或'|'，位非'~'，位异或'^'，右移'>>'，左移'<<'，0填充的右移'>>>'
         * 位运算的位与'&'，位或'|'，位非'~'，位异或'^'与逻辑运算的相应操作的真值表完全相同，
         * 其差别只是位运算操作的操作数和运算结果都是二进制整数，
         * 而逻辑运算相应操作的操作数和运算结果都是逻辑值boolean型
         * 右移是将一个二进制数按指定移动的位数向右移位，移掉的被丢弃，左边移进的部分或者补0（当该数为正时），或者补1（当该数为负时）。
         * 这是因为整数在机器内部采用补码表示法，正数的符号位为0，负数的符号位为1。
         * 将一个数左移"<<"会使该值乘以2的幂。将一个数右移>>"会使该值除以2的幂。
         * 右移（补零）运算符，即无符号右移，">>>"永远不会产生负号，因为其符号位总是被补零。
         * 不论被移动数是正数还是负数，左边移进的部分一律补0。
         */

        /**
         * 5. 赋值运算符
         *  += : s += i : s = s + i : s,i是数值型
         *  -= : s -= i : s = s - i
         *  *= : s *= i : s = s * i
         *  *= : s /= i : s = s / i
         *  %= : s %= i : s = s % i
         *  &= : a &= b : a = a & b : a,b是逻辑型或整整型
         *  |= : a |= b : a = a | b
         *  ^= : a ^= b : a = a ^ b
         * <<= : a <<= b : a = a << b
         * >>= : a >>= b : a = a >> b
         * >>>= : a >>>= b : a = a >>> b
         */

        /**
         * 6. 其他运算符
         * ①方括号[]和圆括号（）运算符
         * ③ 字符串加（+）运算符
         * ④ 条件运算符(三目运算符)
         * ⑤强制类型转换符
         * ⑥对象运算符instanceof
         * ⑦点运算符 : 一是引用类中成员，二是指示包的层次等级
         */

        int m=-7;
        System.out.println("   m的二进制码是："+Integer.toBinaryString(m));
        System.out.println("m>>2的二进制码是："+Integer.toBinaryString(m>>2));
        System.out.println("(m>>2)="+(m>>2));

        System.out.println("   m的二进制码是："+Integer.toBinaryString(m));
        System.out.println("m<<2的二进制码是："+Integer.toBinaryString(m<<2));
        System.out.println("(m<<2)=:"+(m<<2));

        System.out.println("   m的二进制码是："+Integer.toBinaryString(m));
        System.out.println("m>>>24的二进制码是："+Integer.toBinaryString(m>>>24));
        System.out.println(" m>>>24 :"+ (m>>>24));

        /**
         *  原码:符号位加上数字的二进制表示
         *  反码:一个数如果为正，则它的反码与原码相同；
         *       一个数如果为负，则符号位为1，(符号位不变化，其余位数取反)。
         *  补码:一个数如果为正，则它的原码、反码、补码相同；
         *       一个数如果为负，取到反码然后加1。(反码加1就是补码)
         *
         *  内存中的数是以数字的补码存在的，而显示屏上显示的数字是我们人想要表达的
         *
         *  已知一个负数的补码，将其转换为十进制数，步骤
         *   1、先对各位取反；
         *   2、将其转换为十进制数；
         *   3、加上负号，再减去1。
         */
        System.out.println();

        String a = "1";
        String b = "1";
        System.out.println(a == b); // JVM字符串常量池
        String c ="Hello"; //(字符串常量) 或者
        String d ="Hel" + "lo"; //(字符串常量表达式)
        System.out.println(c == d); // JVM字符串常量池

        /**
         * JVM中有一个常量池，任何字符串至多维护一个对象。
         * 字符串常量总是指向字符串池中的一个对象。
         * 通过new操作符创建的字符串对象不指向字符串池中的任何对象，
         * 但是可以通过使用字符串的intern()方法来指向其中的某一个。
         * java.lang.String.intern()返回一个保留池字符串，就是一个在全局字符串池中有了一个入口。
         * 如果以前没有在全局字符串池中，那么它就会被添加到里面。
         */

        /**
         * 同一个包下同一个类中的字符串常量的引用指向同一个字符串对象；
         * 同一个包下不同的类中的字符串常量的引用指向同一个字符串对象；
         * 不同的包下不同的类中的字符串常量的引用仍然指向同一个字符串对象；
         * 由常量表达式计算出的字符串在编译时进行计算,然后被当作常量；
         * 在运行时通过连接计算出的字符串是新创建的，因此是不同的；
         * 通过计算生成的字符串显示调用intern方法后产生的结果与原来存在的同样内容的字符串常量是一样的。
         */
    }
}
